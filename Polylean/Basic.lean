-- notation for the natural numbers
macro_rules
  | `(ℕ) => `(Nat)

/-
The type `Alphabet α` encodes the generators of the free group generated by `α`.
Terms of the form `pos a` (where `a : α`) indicate the generators while terms of the form `neg α` indicate their inverses.
-/
inductive Alphabet (α : Type _) [DecidableEq α] where
  | pos : α → Alphabet α
  | neg : α → Alphabet α
  deriving Repr

-- a type `α` with decidable equality
variable {α : Type _} [DecidableEq α]

-- a proof that `Alphabet α` also has decidable equality
instance : DecidableEq (Alphabet α) := sorry

-- inverse of an alphabet
def Alphabet.inv : Alphabet α → Alphabet α
  | pos a => neg a
  | neg a => pos a

-- notation
postfix:max "⁻¹" => Alphabet.inv

/-
A term of type `Word α` is a word in the free group generated by `α`.
It is convenient to think of it as a list of elements of type `Alphabet α`, as associativity is automatically taken care of.
-/
abbrev Word (α : Type _) [DecidableEq α] := List (Alphabet α)

-- powers of a group element
def Word.pow : Word α → ℕ → Word α
  | w, Nat.zero   => []
  | w, Nat.succ m => w ++ (pow w m)

instance : Pow (Word α) ℕ := ⟨Word.pow⟩

-- conjugation of a word by a generator
def Word.conj : Word α → Alphabet α → Word α
  | w, l => [l] ++ w ++ [l⁻¹]

instance : Pow (Word α) (Alphabet α) := ⟨Word.conj⟩

/-
Reduces a word once by cancelling adjacent elements that are inverses of each other.
-/
def Word.reduceStep : Word α → Word α
  | [] => []
  | Alphabet.pos a :: Alphabet.neg b :: tail =>
    if a = b then
      reduceStep tail
    else
      Alphabet.pos a :: (reduceStep $ Alphabet.neg b :: tail)
  | Alphabet.neg a :: Alphabet.pos b :: tail =>
    if a = b then
      reduceStep tail
    else
      Alphabet.neg a :: (reduceStep $ Alphabet.pos b :: tail)
  | x::tail =>
    reduceStep tail

/-
Reduces a word for `n : ℕ` steps.
-/
def Word.reduce : ℕ → Word α → Word α
  | Nat.zero => id
  | Nat.succ m => reduceStep ∘ (reduce m)

/-
Two words are defined to be equivalent if they eventually reduce to the same word.
A trivial upper bound for the number of steps needed for the two to converge to the same reduced word is the length of the larger of the two lists.
-/
def Word.equiv : Word α → Word α → Prop
  | x, y => ∃ n : ℕ, reduce n x = reduce n y

-- notation, typed `\sim`
infix:100 "∼" => Word.equiv

/-
A proved split of a word `w` at a letter `l` is a pair of words `(fst, snd)` such that `w` splits into `fst` and `snd` at `l`.
abbrev ProvedSplit (l : Alphabet α) (w : Word α) :=
  {
  wordpair : Word α × Word α //
  w = wordpair.fst ++ [l] ++ wordpair.snd
  }
-/

abbrev SizeFunction (α : Type _) [DecidableEq α] := Word α → ℕ

/-
The definition of a pseudo-length function on the free group generated by `α`, implemented as a typeclass.

The letter `ℓ` is typed as `\ell`.
-/
class PseudoLengthFunction (ℓ : SizeFunction α) where
  emptyWord : ℓ [] = Nat.zero
  normalized : ∀ (x : Alphabet α), ℓ [x] = Nat.succ Nat.zero
  conjInv : ∀ (x : Alphabet α) (w : Word α), ℓ (w^x) = ℓ (w)
  triangIneq : ∀ (w w' : Word α), ℓ (w ++ w') ≤ ℓ (w) + ℓ (w')

/-
A proved bound on a word is an upper bound for its length that is guaranteed to word for any pseudo length function.
-/
abbrev ProvedBound (w : Word α) :=
  {
    bound : ℕ //
    ∀ (ℓ : SizeFunction α) [PseudoLengthFunction ℓ],
    ℓ (w) ≤ bound
  }
