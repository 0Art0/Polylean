-- notation for the natural numbers
macro_rules
  | `(ℕ) => `(Nat)

/-
The type `Alphabet α` encodes the generators of the free group generated by `α`.
Terms of the form `pos a` (where `a : α`) indicate the generators while terms of the form `neg α` indicate their inverses.
-/
inductive Alphabet (α : Type _) [DecidableEq α] where
  | pos : α → Alphabet α
  | neg : α → Alphabet α
  deriving Repr

-- a type `α` with decidable equality
variable {α : Type _} [DecidableEq α]


-- a proof that `Alphabet α` also has decidable equality
instance : DecidableEq (Alphabet α) := by
  intro a b ; cases a <;> cases b <;> simp <;>
    exact inferInstance

-- inverse of an alphabet
def Alphabet.inv : Alphabet α → Alphabet α
  | pos a => neg a
  | neg a => pos a

-- notation
postfix:max "⁻¹" => Alphabet.inv

/-
A term of type `Word α` is a word in the free group generated by `α`.
It is convenient to think of it as a list of elements of type `Alphabet α`, as associativity is automatically taken care of.
-/
abbrev Word (α : Type _) [DecidableEq α] := List (Alphabet α)

-- powers of a group element
@[reducible] def Word.pow : Word α → ℕ → Word α
  | w, Nat.zero   => []
  | w, Nat.succ m => w ++ (pow w m)

instance : Pow (Word α) ℕ := ⟨Word.pow⟩

-- conjugation of a word by a generator
@[reducible, simp] def Word.conj : Word α → Alphabet α → Word α
  | w, l => [l] ++ w ++ [l⁻¹]

instance : Pow (Word α) (Alphabet α) := ⟨Word.conj⟩

instance : DecidableEq (Word α) := by
  intro w₁ w₂
  cases w₁ <;> cases w₂ <;> simp <;> exact inferInstance

/-
TODO Rewrite as an inductive definition
Reduces a word once by cancelling adjacent elements that are inverses of each other.
-/
def Word.reduceStep : Word α → Word α
  | [] => []
  | Alphabet.pos a :: Alphabet.neg b :: tail =>
    if a = b then
      reduceStep tail
    else
      Alphabet.pos a :: (reduceStep $ Alphabet.neg b :: tail)
  | Alphabet.neg a :: Alphabet.pos b :: tail =>
    if a = b then
      reduceStep tail
    else
      Alphabet.neg a :: (reduceStep $ Alphabet.pos b :: tail)
  | x::tail =>
    reduceStep tail

/-
Reduces a word for `n : ℕ` steps.
-/
def Word.reduce : ℕ → Word α → Word α
  | Nat.zero => id
  | Nat.succ m => reduceStep ∘ (reduce m)

/-
Two words are defined to be equivalent if they eventually reduce to the same word.
A trivial upper bound for the number of steps needed for the two to converge to the same reduced word is the length of the larger of the two lists.
-/
def Word.equiv : Word α → Word α → Prop
  | x, y => ∃ m n : ℕ, reduce m x = reduce n y

-- notation, typed `\sim`
infix:100 " ∼ " => Word.equiv

abbrev FreeGroupLength (α : Type _) [DecidableEq α] := Word α → ℕ

/-
The definition of a pseudo-length function on the free group generated by `α`, implemented as a typeclass.

The letter `ℓ` is typed as `\ell`.
-/
class PseudoLengthFunction (ℓ : FreeGroupLength α) where
  -- the empty word has length zero
  emptyWord : ℓ [] = Nat.zero
  -- the generators have unit length
  normalized : ∀ (x : Alphabet α), ℓ [x] = Nat.succ Nat.zero
  -- the length is invariant under choice of representatives of the word
  reprInv : ∀ {w w' : Word α}, w ∼ w' → ℓ (w) = ℓ (w')
  -- the length is invariant under conjugation
  conjInv : ∀ (x : Alphabet α) (w : Word α), ℓ (w^x) = ℓ (w)
  -- the length satisfies the triangle inequality
  triangIneq : ∀ (w w' : Word α), ℓ (w ++ w') ≤ ℓ (w) + ℓ (w')

/-
A length bound on a word is an upper bound for the value of any pseudo length function on the given word.
-/
@[reducible] abbrev lengthBound (w : Word α) (bound : ℕ) :=
  ∀ (ℓ : FreeGroupLength α) [PseudoLengthFunction ℓ], ℓ (w) ≤ bound

-- convenient notation
infix:100 " is bounded by " => lengthBound
